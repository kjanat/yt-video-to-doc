import fs from "node:fs/promises";
import path from "node:path";
import type { Slide, VideoMetadata } from "../types";
import logger from "../utils/logger";

export class DocumentGenerator {
	private outputDir: string;

	constructor(outputDir: string) {
		this.outputDir = outputDir;
	}

	async generateMarkdown(
		videoMetadata: VideoMetadata,
		slides: Slide[],
		outputFilename?: string,
	): Promise<string> {
		await fs.mkdir(this.outputDir, { recursive: true });

		const filename =
			outputFilename || `${this.sanitizeFilename(videoMetadata.title)}.md`;
		const outputPath = path.join(this.outputDir, filename);

		const content = this.buildMarkdownContent(videoMetadata, slides);

		await fs.writeFile(outputPath, content, "utf-8");
		logger.info(`Document generated: ${outputPath}`);

		return outputPath;
	}

	private buildMarkdownContent(
		metadata: VideoMetadata,
		slides: Slide[],
	): string {
		const lines: string[] = [];

		// Document header
		lines.push(`# ${metadata.title}`);
		lines.push("");
		lines.push("---");
		lines.push(`**Source:** ${metadata.url}`);
		lines.push(`**Duration:** ${this.formatDuration(metadata.duration)}`);
		lines.push(`**Resolution:** ${metadata.resolution}`);
		lines.push(`**Generated:** ${new Date().toISOString()}`);
		lines.push("---");
		lines.push("");

		// Table of contents
		if (slides.length > 3) {
			lines.push("## Table of Contents");
			lines.push("");
			slides.forEach((slide, index) => {
				const slideTitle = this.getSlideTitle(slide, index + 1);
				lines.push(`- [${slideTitle}](#slide-${index + 1})`);
			});
			lines.push("");
		}

		// Slide content
		slides.forEach((slide, index) => {
			lines.push(`## Slide ${index + 1}`);
			lines.push("");
			lines.push(
				`**Time:** ${this.formatTimestamp(slide.startTime)} - ${this.formatTimestamp(slide.endTime)}`,
			);
			lines.push("");

			if (slide.primaryText) {
				lines.push("### Content");
				lines.push("");
				lines.push(this.formatSlideText(slide.primaryText));
				lines.push("");
			} else {
				lines.push("*No text detected in this slide*");
				lines.push("");
			}

			// Add frame reference
			const representativeFrame =
				slide.frames[Math.floor(slide.frames.length / 2)];
			lines.push(
				`> Frame: ${representativeFrame.frameNumber} at ${this.formatTimestamp(representativeFrame.timestamp)}`,
			);
			lines.push("");
			lines.push("---");
			lines.push("");
		});

		// Footer
		lines.push("");
		lines.push("---");
		lines.push("*Generated by YouTube Video to Text Converter*");

		return lines.join("\n");
	}

	private getSlideTitle(slide: Slide, slideNumber: number): string {
		if (slide.primaryText) {
			// Use first line or first 50 characters as title
			const firstLine = slide.primaryText.split("\n")[0].trim();
			const title =
				firstLine.length > 50 ? `${firstLine.substring(0, 47)}...` : firstLine;
			return title || `Slide ${slideNumber}`;
		}
		return `Slide ${slideNumber}`;
	}

	private formatSlideText(text: string): string {
		// Clean up OCR text
		return text
			.split("\n")
			.map((line) => line.trim())
			.filter((line) => line.length > 0)
			.join("\n\n");
	}

	private formatDuration(seconds: number): string {
		const hours = Math.floor(seconds / 3600);
		const minutes = Math.floor((seconds % 3600) / 60);
		const secs = Math.floor(seconds % 60);

		if (hours > 0) {
			return `${hours}h ${minutes}m ${secs}s`;
		} else if (minutes > 0) {
			return `${minutes}m ${secs}s`;
		} else {
			return `${secs}s`;
		}
	}

	private formatTimestamp(seconds: number): string {
		const hours = Math.floor(seconds / 3600);
		const minutes = Math.floor((seconds % 3600) / 60);
		const secs = Math.floor(seconds % 60);

		if (hours > 0) {
			return `${hours}:${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
		} else {
			return `${minutes}:${secs.toString().padStart(2, "0")}`;
		}
	}

	private sanitizeFilename(filename: string): string {
		return filename
			.replace(/[^a-z0-9]/gi, "_")
			.replace(/_+/g, "_")
			.toLowerCase()
			.substring(0, 100);
	}
}
